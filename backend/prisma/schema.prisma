// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

// Looking for ways to speed up your queries, or scale easily with your serverless or edge functions?
// Try Prisma Accelerate: https://pris.ly/cli/accelerate-init

generator client {
  provider = "prisma-client"
  output   = "../src/generated/prisma"
}

datasource db {
  provider = "postgresql"
}

model User {
  id             String   @id @default(uuid())
  email          String   @unique
  password       String
  emailVerified  Boolean  @default(false)
  refreshTokens               RefreshToken[]
  deletedAt      DateTime?
  createdAt      DateTime @default(now()) @map("created_at")
  updatedAt      DateTime @updatedAt @map("updated_at")

  cvs                Cv[]
  jobDescriptions    JobDescription[]
  verificationCodes  EmailVerification[]

  @@index([createdAt])
}

model EmailVerification {
  id         String              @id @default(uuid())
  userId     String
  codeHash   String
  type       VerificationCodeType
  expiresAt  DateTime
  used       Boolean             @default(false)
  createdAt  DateTime            @default(now())

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([expiresAt])
  @@index([used])
  @@index([createdAt])
  @@index([type])
  @@index([userId, type, used, expiresAt])
  @@index([userId, used, expiresAt])
}

enum VerificationCodeType {
  EMAIL_VERIFICATION
  FORGOT_PASSWORD
}

model Cv {
  id        String   @id @default(uuid())
  userId    String
  status    CvStatus
  createdAt DateTime @default(now())

  user     User @relation(fields: [userId], references: [id], onDelete: Cascade)
  sections CvSection[]

  @@index([userId])
}

enum CvStatus {
  UPLOADED
  PARSED
  EVALUATED
}

model CvSection {
  id     String @id @default(uuid())
  cvId   String
  type   CvSectionType
  order  Int

  cv     Cv @relation(fields: [cvId], references: [id], onDelete: Cascade)
  chunks CvChunk[]

  @@index([cvId])
}

enum CvSectionType {
  SUMMARY
  EXPERIENCE
  PROJECTS
  SKILLS
  EDUCATION
  ACTIVITIES
}

model CvChunk {
  id        String   @id @default(uuid())
  sectionId String
  order     Int
  content   String

  // pgvector embedding
  embedding Unsupported("vector(768)")?

  section CvSection @relation(fields: [sectionId], references: [id], onDelete: Cascade)

  @@index([sectionId])
}

model JobDescription {
  id        String   @id @default(uuid())
  userId    String
  title     String?
  createdAt DateTime @default(now())

  user  User @relation(fields: [userId], references: [id], onDelete: Cascade)
  rules JDRule[]

  @@index([userId])
}

// JD paragraph classification for noise filtering
enum JDParagraphType {
  REQUIREMENTS      // must, required, minimum, qualifications
  RESPONSIBILITIES  // you will, role includes, contribute to
  NICE_TO_HAVE      // preferred, bonus, plus
  BENEFITS          // salary, benefits, healthcare (ignored)
  COMPANY           // culture, we offer, inclusive (ignored)
  PROCESS           // deadline, recruitment process (ignored)
  UNKNOWN           // unclassified
}

model JDRule {
  id            String          @id @default(uuid())
  jdId          String
  ruleType      RuleType
  content       String
  paragraphType JDParagraphType @default(UNKNOWN) // for noise filtering
  ignored       Boolean         @default(false)   // true if BENEFITS/COMPANY/PROCESS

  jd     JobDescription @relation(fields: [jdId], references: [id], onDelete: Cascade)
  chunks JDRuleChunk[]

  @@index([jdId])
  @@index([paragraphType])
  @@index([ignored])
}

model JDRuleChunk {
  id          String @id @default(uuid())
  ruleId      String
  chunkKey    String?  // stable hash for deduplication (optional for backwards compat)
  order       Int      @default(0)
  content     String   // <= 300 chars
  contentHash String?  // hash of normalized content

  // pgvector embedding
  embedding Unsupported("vector(768)")?

  rule JDRule @relation(fields: [ruleId], references: [id], onDelete: Cascade)

  @@index([ruleId])
  @@index([chunkKey])
}

enum RuleType {
  MUST_HAVE
  NICE_TO_HAVE
  BEST_PRACTICE
}

// =============================================================================
// RULE SETS (CV Quality Rules + JD Matching Rules from PDFs)
// =============================================================================

enum RuleStrategy {
  STRUCTURAL // enforced by code-based detectors (email, phone, date, section presence)
  SEMANTIC   // evaluated via embeddings + cosine similarity
  HYBRID     // requires both structural check + semantic evidence
}

enum RuleSeverity {
  critical
  warning
  info
}

model RuleSet {
  id                  String   @id @default(uuid())
  key                 String   @unique // e.g. "cv-quality-student-fresher", "jd-matching-v1"
  sourcePdf           String   // original PDF filename
  version             String   // e.g. "2026-02-03"
  embeddingProvider   String   @default("gemini")
  embeddingModel      String   @default("text-embedding-004")
  embeddingDimension  Int      @default(768)
  vectorOperator      String   @default("<=>") // pgvector cosine distance
  similarityTransform String   @default("1 - distance") // formula
  createdAt           DateTime @default(now())

  rules CvQualityRule[]

  @@index([key])
  @@index([createdAt])
}

model CvQualityRule {
  id                 String       @id @default(uuid())
  ruleSetId          String
  ruleKey            String       // stable, deterministic (e.g. S-MH-01)
  category           RuleType     // MUST_HAVE | NICE_TO_HAVE | BEST_PRACTICE
  severity           RuleSeverity
  strategy           RuleStrategy
  title              String?      // optional human-readable title
  content            String       // normalized full rule text
  appliesToSections  Json?        // JSON array of CvSectionType or null (global)
  structuralCheckKey String?      // key for structural detector (e.g. "email_present")
  params             Json?        // detector configuration parameters
  order              Int          @default(0) // order within rule set
  createdAt          DateTime     @default(now())

  ruleSet RuleSet          @relation(fields: [ruleSetId], references: [id], onDelete: Cascade)
  chunks  CvQualityRuleChunk[]

  @@unique([ruleSetId, ruleKey])
  @@index([ruleSetId])
  @@index([ruleKey])
  @@index([category])
  @@index([strategy])
}

model CvQualityRuleChunk {
  id          String   @id @default(uuid())
  ruleId      String
  chunkKey    String   // stable, deterministic hash(ruleKey + order + content)
  order       Int
  content     String   // <= 300 chars
  contentHash String   // hash of normalized content for deduplication
  createdAt   DateTime @default(now())

  // pgvector embedding
  embedding Unsupported("vector(768)")?

  rule CvQualityRule @relation(fields: [ruleId], references: [id], onDelete: Cascade)

  @@unique([ruleId, chunkKey])
  @@index([ruleId])
  @@index([chunkKey])
}

model RefreshToken {
  id        String   @id @default(uuid())
  userId    String
  token     String
  expiresAt DateTime
  createdAt DateTime @default(now())

  user User @relation(fields: [userId], references: [id], onDelete: Cascade, onUpdate: NoAction)

  @@index([expiresAt])
  @@index([createdAt])
}